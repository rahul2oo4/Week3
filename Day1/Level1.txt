1. Singly Linked List: Student Record Management
Problem Statement: Create a program to manage student records using a singly linked list. Each node will store information about a student, including their Roll Number, Name, Age, and Grade. Implement the following operations:
Add a new student record at the beginning, end, or at a specific position.
Delete a student record by Roll Number.
Search for a student record by Roll Number.
Display all student records.
Update a student's grade based on their Roll Number.
Hint:
Use a singly linked list where each node contains student information and a pointer to the next node.
The head of the list will represent the first student, and the last node’s next pointer will be null.
Update the next pointers when inserting or deleting nodes.


class Roll_num {
   static class Student {
       int rollNumber;
       String name;
       int age;
       String grade;
       Student next;

       Student(int rollNumber, String name, int age, String grade) {
           this.rollNumber = rollNumber;
           this.name = name;
           this.age = age;
           this.grade = grade;
           this.next = null;
       }
   }

   private Student head;

   public void addAtBeginning(int rollNumber, String name, int age, String grade) {
       Student newStudent = new Student(rollNumber, name, age, grade);
       newStudent.next = head;
       head = newStudent;
   }

   public void addAtEnd(int rollNumber, String name, int age, String grade) {
       Student newStudent = new Student(rollNumber, name, age, grade);
       if (head == null) {
           head = newStudent;
           return;
       }
       Student temp = head;
       while (temp.next != null) {
           temp = temp.next;
       }
       temp.next = newStudent;
   }

   public void addAtPosition(int position, int rollNumber, String name, int age, String grade) {
       if (position == 0) {
           addAtBeginning(rollNumber, name, age, grade);
           return;
       }
       Student newStudent = new Student(rollNumber, name, age, grade);
       Student temp = head;
       for (int i = 0; i < position - 1 && temp != null; i++) {
           temp = temp.next;
       }
       if (temp == null) return;
       newStudent.next = temp.next;
       temp.next = newStudent;
   }

   public void deleteByRollNumber(int rollNumber) {
       if (head == null) return;
       if (head.rollNumber == rollNumber) {
           head = head.next;
           return;
       }
       Student temp = head;
       while (temp.next != null && temp.next.rollNumber != rollNumber) {
           temp = temp.next;
       }
       if (temp.next == null) return;
       temp.next = temp.next.next;
   }

   public Student searchByRollNumber(int rollNumber) {
       Student temp = head;
       while (temp != null) {
           if (temp.rollNumber == rollNumber) return temp;
           temp = temp.next;
       }
       return null;
   }

   public void displayAll() {
       Student temp = head;
       while (temp != null) {
           System.out.println("Roll Number: " + temp.rollNumber + ", Name: " + temp.name + ", Age: " + temp.age + ", Grade: " + temp.grade);
           temp = temp.next;
       }
   }

   public void updateGrade(int rollNumber, String newGrade) {
       Student temp = searchByRollNumber(rollNumber);
       if (temp != null) {
           temp.grade = newGrade;
       }
   }

   public static void main(String[] args) {
       Roll_num list = new Roll_num();
       list.addAtEnd(1, "Alice", 20, "A");
       list.addAtBeginning(2, "Bob", 21, "B");
       list.addAtPosition(1, 3, "Charlie", 22, "C");
       list.displayAll();
       list.updateGrade(2, "A+");
       list.displayAll();
       list.deleteByRollNumber(1);
       list.displayAll();
       Student student = list.searchByRollNumber(3);
       if (student != null) {
           System.out.println("Found: Roll Number: " + student.rollNumber + ", Name: " + student.name);
       }
   }
}



2. Doubly Linked List: Movie Management System
Problem Statement: Implement a movie management system using a doubly linked list. Each node will represent a movie and contain Movie Title, Director, Year of Release, and Rating. Implement the following functionalities:
Add a movie record at the beginning, end, or at a specific position.
Remove a movie record by Movie Title.
Search for a movie record by Director or Rating.
Display all movie records in both forward and reverse order.
Update a movie's Rating based on the Movie Title.
Hint:
Use a doubly linked list where each node has two pointers: one pointing to the next node and the other to the previous node.
Maintain pointers to both the head and tail for easier insertion and deletion at both ends.
For reverse display, start from the tail and traverse backward using the prev pointers.


public class Movie {
   String title;
   String director;
   int yearOfRelease;
   double rating;
   Movie next;
   Movie prev;

   public Movie(String title, String director, int yearOfRelease, double rating) {
       this.title = title;
       this.director = director;
       this.yearOfRelease = yearOfRelease;
       this.rating = rating;
   }
}

class MovieManagementSystem {
   private Movie head;
   private Movie tail;

   public void addMovieAtBeginning(String title, String director, int yearOfRelease, double rating) {
       Movie newMovie = new Movie(title, director, yearOfRelease, rating);
       if (head == null) {
           head = tail = newMovie;
       } else {
           newMovie.next = head;
           head.prev = newMovie;
           head = newMovie;
       }
   }

   public void addMovieAtEnd(String title, String director, int yearOfRelease, double rating) {
       Movie newMovie = new Movie(title, director, yearOfRelease, rating);
       if (tail == null) {
           head = tail = newMovie;
       } else {
           tail.next = newMovie;
           newMovie.prev = tail;
           tail = newMovie;
       }
   }

   public void addMovieAtPosition(String title, String director, int yearOfRelease, double rating, int position) {
       if (position <= 0) {
           addMovieAtBeginning(title, director, yearOfRelease, rating);
           return;
       }
       Movie newMovie = new Movie(title, director, yearOfRelease, rating);
       Movie current = head;
       for (int i = 0; i < position - 1 && current != null; i++) {
           current = current.next;
       }
       if (current == null) {
           addMovieAtEnd(title, director, yearOfRelease, rating);
       } else {
           newMovie.next = current.next;
           newMovie.prev = current;
           if (current.next != null) {
               current.next.prev = newMovie;
           }
           current.next = newMovie;
           if (newMovie.next == null) {
               tail = newMovie;
           }
       }
   }

   public void removeMovieByTitle(String title) {
       Movie current = head;
       while (current != null) {
           if (current.title.equals(title)) {
               if (current.prev != null) {
                   current.prev.next = current.next;
               } else {
                   head = current.next;
               }
               if (current.next != null) {
                   current.next.prev = current.prev;
               } else {
                   tail = current.prev;
               }
               return;
           }
           current = current.next;
       }
   }

   public void searchByDirector(String director) {
       Movie current = head;
       while (current != null) {
           if (current.director.equals(director)) {
               System.out.println(current.title + " " + current.yearOfRelease + " " + current.rating);
           }
           current = current.next;
       }
   }

   public void searchByRating(double rating) {
       Movie current = head;
       while (current != null) {
           if (current.rating == rating) {
               System.out.println(current.title + " " + current.director + " " + current.yearOfRelease);
           }
           current = current.next;
       }
   }

   public void displayForward() {
       Movie current = head;
       while (current != null) {
           System.out.println(current.title + " " + current.director + " " + current.yearOfRelease + " " + current.rating);
           current = current.next;
       }
   }

   public void displayReverse() {
       Movie current = tail;
       while (current != null) {
           System.out.println(current.title + " " + current.director + " " + current.yearOfRelease + " " + current.rating);
           current = current.prev;
       }
   }

   public void updateRating(String title, double newRating) {
       Movie current = head;
       while (current != null) {
           if (current.title.equals(title)) {
               current.rating = newRating;
               return;
           }
           current = current.next;
       }
   }
}




3. Circular Linked List: Task Scheduler
Problem Statement: Create a task scheduler using a circular linked list. Each node in the list represents a task with Task ID, Task Name, Priority, and Due Date. Implement the following functionalities:
Add a task at the beginning, end, or at a specific position in the circular list.
Remove a task by Task ID.
View the current task and move to the next task in the circular list.
Display all tasks in the list starting from the head node.
Search for a task by Priority.
Hint:
Use a circular linked list where the last node’s next pointer points back to the first node, creating a circular structure.
Ensure that the list loops when traversed from the head node, so tasks can be revisited in a circular manner.
When deleting or adding tasks, maintain the circular nature by updating the appropriate next pointers.


import java.util.Date;

class Task {
   int taskId;
   String taskName;
   int priority;
   String dueDate;
   Task next;

   public Task(int taskId, String taskName, int priority, String dueDate) {
       this.taskId = taskId;
       this.taskName = taskName;
       this.priority = priority;
       this.dueDate = dueDate;
       this.next = null;
   }
}

public class TaskScheduler {
   private Task head = null;

   public void addTaskAtBeginning(int taskId, String taskName, int priority, String dueDate) {
       Task newTask = new Task(taskId, taskName, priority, dueDate);
       if (head == null) {
           head = newTask;
           head.next = head;
       } else {
           Task temp = head;
           while (temp.next != head) {
               temp = temp.next;
           }
           newTask.next = head;
           temp.next = newTask;
           head = newTask;
       }
   }

   public void addTaskAtEnd(int taskId, String taskName, int priority, String dueDate) {
       Task newTask = new Task(taskId, taskName, priority, dueDate);
       if (head == null) {
           head = newTask;
           head.next = head;
       } else {
           Task temp = head;
           while (temp.next != head) {
               temp = temp.next;
           }
           temp.next = newTask;
           newTask.next = head;
       }
   }

   public void addTaskAtPosition(int taskId, String taskName, int priority, String dueDate, int position) {
       Task newTask = new Task(taskId, taskName, priority, dueDate);
       if (position == 1) {
           addTaskAtBeginning(taskId, taskName, priority, dueDate);
           return;
       }
       Task temp = head;
       for (int i = 1; i < position - 1 && temp.next != head; i++) {
           temp = temp.next;
       }
       newTask.next = temp.next;
       temp.next = newTask;
   }

   public void removeTaskById(int taskId) {
       if (head == null) return;
       if (head.taskId == taskId && head.next == head) {
           head = null;
           return;
       }
       Task temp = head, prev = null;
       do {
           if (temp.taskId == taskId) {
               if (prev == null) {
                   Task last = head;
                   while (last.next != head) {
                       last = last.next;
                   }
                   head = head.next;
                   last.next = head;
               } else {
                   prev.next = temp.next;
               }
               return;
           }
           prev = temp;
           temp = temp.next;
       } while (temp != head);
   }

   public Task viewCurrentTask() {
       return head;
   }

   public void moveToNextTask() {
       if (head != null) {
           head = head.next;
       }
   }

   public void displayAllTasks() {
       if (head == null) return;
       Task temp = head;
       do {
           System.out.println("Task ID: " + temp.taskId + ", Task Name: " + temp.taskName + ", Priority: " + temp.priority + ", Due Date: " + temp.dueDate);
           temp = temp.next;
       } while (temp != head);
   }

   public void searchTaskByPriority(int priority) {
       if (head == null) return;
       Task temp = head;
       do {
           if (temp.priority == priority) {
               System.out.println("Task ID: " + temp.taskId + ", Task Name: " + temp.taskName + ", Priority: " + temp.priority + ", Due Date: " + temp.dueDate);
           }
           temp = temp.next;
       } while (temp != head);
   }

   public static void main(String[] args) {
       TaskScheduler scheduler = new TaskScheduler();
       scheduler.addTaskAtBeginning(1, "Task1", 5, "2023-10-01");
       scheduler.addTaskAtEnd(2, "Task2", 3, "2023-10-02");
       scheduler.addTaskAtPosition(3, "Task3", 4, "2023-10-03", 2);
       scheduler.displayAllTasks();
       scheduler.removeTaskById(2);
       scheduler.displayAllTasks();
       scheduler.searchTaskByPriority(4);
       System.out.println("Current Task: " + scheduler.viewCurrentTask().taskName);
       scheduler.moveToNextTask();
       System.out.println("Next Task: " + scheduler.viewCurrentTask().taskName);
   }
}



4. Singly Linked List: Inventory Management System
Problem Statement: Design an inventory management system using a singly linked list where each node stores information about an item such as Item Name, Item ID, Quantity, and Price. Implement the following functionalities:
Add an item at the beginning, end, or at a specific position.
Remove an item based on Item ID.
Update the quantity of an item by Item ID.
Search for an item based on Item ID or Item Name.
Calculate and display the total value of inventory (Sum of Price * Quantity for each item).
Sort the inventory based on Item Name or Price in ascending or descending order.
Hint:
Use a singly linked list where each node represents an item in the inventory.
Implement sorting using an appropriate algorithm (e.g., merge sort) on the linked list.
For total value calculation, traverse through the list and sum up Quantity * Price for each item.
import java.util.Scanner;

class Inventory {
   String itemName;
   int itemId;
   int quantity;
   double price;
   Inventory next;

   public Inventory(String itemName, int itemId, int quantity, double price) {
       this.itemName = itemName;
       this.itemId = itemId;
       this.quantity = quantity;
       this.price = price;
       this.next = null;
   }
}

class InventoryManagement {
   private Inventory head;

   public void addItemAtBeginning(String itemName, int itemId, int quantity, double price) {
       Inventory newItem = new Inventory(itemName, itemId, quantity, price);
       newItem.next = head;
       head = newItem;
   }

   public void addItemAtEnd(String itemName, int itemId, int quantity, double price) {
       Inventory newItem = new Inventory(itemName, itemId, quantity, price);
       if (head == null) {
           head = newItem;
           return;
       }
       Inventory temp = head;
       while (temp.next != null) {
           temp = temp.next;
       }
       temp.next = newItem;
   }

   public void addItemAtPosition(String itemName, int itemId, int quantity, double price, int position) {
       Inventory newItem = new Inventory(itemName, itemId, quantity, price);
       if (position == 0) {
           newItem.next = head;
           head = newItem;
           return;
       }
       Inventory temp = head;
       for (int i = 0; i < position - 1 && temp != null; i++) {
           temp = temp.next;
       }
       if (temp == null) return;
       newItem.next = temp.next;
       temp.next = newItem;
   }

   public void removeItemById(int itemId) {
       if (head == null) return;
       if (head.itemId == itemId) {
           head = head.next;
           return;
       }
       Inventory temp = head;
       while (temp.next != null && temp.next.itemId != itemId) {
           temp = temp.next;
       }
       if (temp.next == null) return;
       temp.next = temp.next.next;
   }

   public void updateQuantityById(int itemId, int newQuantity) {
       Inventory temp = head;
       while (temp != null) {
           if (temp.itemId == itemId) {
               temp.quantity = newQuantity;
               return;
           }
           temp = temp.next;
       }
   }

   public Inventory searchById(int itemId) {
       Inventory temp = head;
       while (temp != null) {
           if (temp.itemId == itemId) return temp;
           temp = temp.next;
       }
       return null;
   }

   public Inventory searchByName(String itemName) {
       Inventory temp = head;
       while (temp != null) {
           if (temp.itemName.equals(itemName)) return temp;
           temp = temp.next;
       }
       return null;
   }

   public double calculateTotalValue() {
       double totalValue = 0;
       Inventory temp = head;
       while (temp != null) {
           totalValue += temp.quantity * temp.price;
           temp = temp.next;
       }
       return totalValue;
   }

   public void sortByName(boolean ascending) {
       head = mergeSort(head, ascending, true);
   }

   public void sortByPrice(boolean ascending) {
       head = mergeSort(head, ascending, false);
   }

   private Inventory mergeSort(Inventory head, boolean ascending, boolean sortByName) {
       if (head == null || head.next == null) return head;
       Inventory middle = getMiddle(head);
       Inventory nextOfMiddle = middle.next;
       middle.next = null;
       Inventory left = mergeSort(head, ascending, sortByName);
       Inventory right = mergeSort(nextOfMiddle, ascending, sortByName);
       return merge(left, right, ascending, sortByName);
   }

   private Inventory merge(Inventory left, Inventory right, boolean ascending, boolean sortByName) {
       if (left == null) return right;
       if (right == null) return left;
       boolean condition = sortByName
               ? (ascending ? left.itemName.compareTo(right.itemName) <= 0 : left.itemName.compareTo(right.itemName) > 0)
               : (ascending ? left.price <= right.price : left.price > right.price);
       if (condition) {
           left.next = merge(left.next, right, ascending, sortByName);
           return left;
       } else {
           right.next = merge(left, right.next, ascending, sortByName);
           return right;
       }
   }

   private Inventory getMiddle(Inventory head) {
       if (head == null) return head;
       Inventory slow = head, fast = head.next;
       while (fast != null && fast.next != null) {
           slow = slow.next;
           fast = fast.next.next;
       }
       return slow;
   }

   public void displayInventory() {
       Inventory temp = head;
       while (temp != null) {
           System.out.println("Item Name: " + temp.itemName + ", Item ID: " + temp.itemId + ", Quantity: " + temp.quantity + ", Price: " + temp.price);
           temp = temp.next;
       }
   }

   public static void main(String[] args) {
       InventoryManagement inventory = new InventoryManagement();
       Scanner scanner = new Scanner(System.in);
       while (true) {
           System.out.println("1. Add Item at Beginning");
           System.out.println("2. Add Item at End");
           System.out.println("3. Add Item at Position");
           System.out.println("4. Remove Item by ID");
           System.out.println("5. Update Quantity by ID");
           System.out.println("6. Search by ID");
           System.out.println("7. Search by Name");
           System.out.println("8. Calculate Total Value");
           System.out.println("9. Sort by Name");
           System.out.println("10. Sort by Price");
           System.out.println("11. Display Inventory");
           System.out.println("12. Exit");
           int choice = scanner.nextInt();
           switch (choice) {
               case 1:
                   System.out.println("Enter Item Name, ID, Quantity, Price:");
                   inventory.addItemAtBeginning(scanner.next(), scanner.nextInt(), scanner.nextInt(), scanner.nextDouble());
                   break;
               case 2:
                   System.out.println("Enter Item Name, ID, Quantity, Price:");
                   inventory.addItemAtEnd(scanner.next(), scanner.nextInt(), scanner.nextInt(), scanner.nextDouble());
                   break;
               case 3:
                   System.out.println("Enter Item Name, ID, Quantity, Price, Position:");
                   inventory.addItemAtPosition(scanner.next(), scanner.nextInt(), scanner.nextInt(), scanner.nextDouble(), scanner.nextInt());
                   break;
               case 4:
                   System.out.println("Enter Item ID to Remove:");
                   inventory.removeItemById(scanner.nextInt());
                   break;
               case 5:
                   System.out.println("Enter Item ID and New Quantity:");
                   inventory.updateQuantityById(scanner.nextInt(), scanner.nextInt());
                   break;
               case 6:
                   System.out.println("Enter Item ID to Search:");
                   Inventory itemById = inventory.searchById(scanner.nextInt());
                   if (itemById != null) {
                       System.out.println("Item Found: " + itemById.itemName);
                   } else {
                       System.out.println("Item Not Found");
                   }
                   break;
               case 7:
                   System.out.println("Enter Item Name to Search:");
                   Inventory itemByName = inventory.searchByName(scanner.next());
                   if (itemByName != null) {
                       System.out.println("Item Found: " + itemByName.itemName);
                   } else {
                       System.out.println("Item Not Found");
                   }
                   break;
               case 8:
                   System.out.println("Total Inventory Value: " + inventory.calculateTotalValue());
                   break;
               case 9:
                   System.out.println("Sort by Name (1 for Ascending, 0 for Descending):");
                   inventory.sortByName(scanner.nextInt() == 1);
                   break;
               case 10:
                   System.out.println("Sort by Price (1 for Ascending, 0 for Descending):");
                   inventory.sortByPrice(scanner.nextInt() == 1);
                   break;
               case 11:
                   inventory.displayInventory();
                   break;
               case 12:
                   scanner.close();
                   return;
           }
       }
   }
}


5. Doubly Linked List: Library Management System
Problem Statement: Design a library management system using a doubly linked list. Each node represents a book and contains the following attributes: Book Title, Author, Genre, Book ID, and Availability Status. Implement the following functionalities:
Add a new book at the beginning, end, or at a specific position.
Remove a book by Book ID.
Search for a book by Book Title or Author.
Update a book’s Availability Status.
Display all books in forward and reverse order.
Count the total number of books in the library.
Hint:
Use a doubly linked list with two pointers (next and prev) in each node to facilitate traversal in both directions.
Ensure that when removing a book, both the next and prev pointers are correctly updated.
Displaying in reverse order will require traversal from the last node using prev pointers.
Displaying in reverse order will require traversal from the last node using prev pointers.
import java.util.Scanner;

class Book {
   String title;
   String author;
   String genre;
   int bookID;
   boolean isAvailable;
   Book next;
   Book prev;

   public Book(String title, String author, String genre, int bookID, boolean isAvailable) {
       this.title = title;
       this.author = author;
       this.genre = genre;
       this.bookID = bookID;
       this.isAvailable = isAvailable;
       this.next = null;
       this.prev = null;
   }
}

public class Library {
   private Book head;
   private Book tail;
   private int count;

   public Library() {
       this.head = null;
       this.tail = null;
       this.count = 0;
   }

   public void addBook(String title, String author, String genre, int bookID, boolean isAvailable, int position) {
       Book newBook = new Book(title, author, genre, bookID, isAvailable);
       if (position <= 0 || head == null) {
           newBook.next = head;
           if (head != null) head.prev = newBook;
           head = newBook;
           if (tail == null) tail = newBook;
       } else if (position >= count) {
           newBook.prev = tail;
           if (tail != null) tail.next = newBook;
           tail = newBook;
           if (head == null) head = newBook;
       } else {
           Book current = head;
           for (int i = 0; i < position - 1; i++) current = current.next;
           newBook.next = current.next;
           newBook.prev = current;
           if (current.next != null) current.next.prev = newBook;
           current.next = newBook;
       }
       count++;
   }

   public void removeBook(int bookID) {
       Book current = head;
       while (current != null && current.bookID != bookID) current = current.next;
       if (current == null) return;
       if (current.prev != null) current.prev.next = current.next;
       else head = current.next;
       if (current.next != null) current.next.prev = current.prev;
       else tail = current.prev;
       count--;
   }

   public void searchBook(String query) {
       Book current = head;
       while (current != null) {
           if (current.title.equalsIgnoreCase(query) || current.author.equalsIgnoreCase(query)) {
               System.out.println("Book Found: " + current.title + " by " + current.author);
               return;
           }
           current = current.next;
       }
       System.out.println("Book not found.");
   }

   public void updateAvailability(int bookID, boolean isAvailable) {
       Book current = head;
       while (current != null) {
           if (current.bookID == bookID) {
               current.isAvailable = isAvailable;
               System.out.println("Availability updated.");
               return;
           }
           current = current.next;
       }
       System.out.println("Book not found.");
   }

   public void displayBooks(boolean reverse) {
       if (reverse) {
           Book current = tail;
           while (current != null) {
               System.out.println(current.title + " by " + current.author + " (ID: " + current.bookID + ", Available: " + current.isAvailable + ")");
               current = current.prev;
           }
       } else {
           Book current = head;
           while (current != null) {
               System.out.println(current.title + " by " + current.author + " (ID: " + current.bookID + ", Available: " + current.isAvailable + ")");
               current = current.next;
           }
       }
   }

   public int countBooks() {
       return count;
   }

   public static void main(String[] args) {
       Library library = new Library();
       Scanner scanner = new Scanner(System.in);

       while (true) {
           System.out.println("\n1. Add Book\n2. Remove Book\n3. Search Book\n4. Update Availability\n5. Display Books\n6. Count Books\n7. Exit");
           int choice = scanner.nextInt();
           scanner.nextLine();

           switch (choice) {
               case 1:
                   System.out.println("Enter Title, Author, Genre, Book ID, Availability (true/false), and Position:");
                   String title = scanner.nextLine();
                   String author = scanner.nextLine();
                   String genre = scanner.nextLine();
                   int bookID = scanner.nextInt();
                   boolean isAvailable = scanner.nextBoolean();
                   int position = scanner.nextInt();
                   library.addBook(title, author, genre, bookID, isAvailable, position);
                   break;
               case 2:
                   System.out.println("Enter Book ID to remove:");
                   int removeID = scanner.nextInt();
                   library.removeBook(removeID);
                   break;
               case 3:
                   System.out.println("Enter Title or Author to search:");
                   String query = scanner.nextLine();
                   library.searchBook(query);
                   break;
               case 4:
                   System.out.println("Enter Book ID and new Availability (true/false):");
                   int updateID = scanner.nextInt();
                   boolean availability = scanner.nextBoolean();
                   library.updateAvailability(updateID, availability);
                   break;
               case 5:
                   System.out.println("Display in reverse order? (true/false):");
                   boolean reverse = scanner.nextBoolean();
                   library.displayBooks(reverse);
                   break;
               case 6:
                   System.out.println("Total Books: " + library.countBooks());
                   break;
               case 7:
                   scanner.close();
                   return;
               default:
                   System.out.println("Invalid choice.");
           }
       }
   }
}




6. Circular Linked List: Round Robin Scheduling Algorithm
Problem Statement: Implement a round-robin CPU scheduling algorithm using a circular linked list. Each node will represent a process and contain Process ID, Burst Time, and Priority. Implement the following functionalities:
Add a new process at the end of the circular list.
Remove a process by Process ID after its execution.
Simulate the scheduling of processes in a round-robin manner with a fixed time quantum.
Display the list of processes in the circular queue after each round.
Calculate and display the average waiting time and turn-around time for all processes.
Hint:
Use a circular linked list to represent a queue of processes.
Each process executes for a fixed time quantum, and then control moves to the next process in the circular list.
Maintain the current node as the process being executed, and after each round, update the list to simulate execution.


import java.util.Scanner;

class Process {
   int processID;
   int burstTime;
   int priority;
   Process next;

   Process(int processID, int burstTime, int priority) {
       this.processID = processID;
       this.burstTime = burstTime;
       this.priority = priority;
       this.next = null;
   }
}

class RoundRobin {
   private Process head = null;
   private Process tail = null;

   public void addProcess(int processID, int burstTime, int priority) {
       Process newProcess = new Process(processID, burstTime, priority);
       if (head == null) {
           head = newProcess;
           tail = newProcess;
           tail.next = head;
       } else {
           tail.next = newProcess;
           tail = newProcess;
           tail.next = head;
       }
   }

   public void removeProcess(int processID) {
       if (head == null) return;
       Process current = head, prev = null;
       do {
           if (current.processID == processID) {
               if (current == head) {
                   head = head.next;
                   tail.next = head;
               } else {
                   prev.next = current.next;
                   if (current == tail) tail = prev;
               }
               return;
           }
           prev = current;
           current = current.next;
       } while (current != head);
   }

   public void simulateRoundRobin(int timeQuantum) {
       if (head == null) return;
       int totalProcesses = 0, totalWaitingTime = 0, totalTurnAroundTime = 0;
       Process current = head;
       do {
           totalProcesses++;
           current = current.next;
       } while (current != head);

       current = head;
       int[] waitingTime = new int[totalProcesses];
       int[] turnAroundTime = new int[totalProcesses];
       int index = 0;

       while (head != null) {
           if (current.burstTime > 0) {
               int executionTime = Math.min(current.burstTime, timeQuantum);
               current.burstTime -= executionTime;

               for (int i = 0; i < totalProcesses; i++) {
                   if (waitingTime[i] != -1 && i != index) {
                       waitingTime[i] += executionTime;
                   }
               }

               if (current.burstTime == 0) {
                   turnAroundTime[index] = waitingTime[index] + executionTime;
                   totalWaitingTime += waitingTime[index];
                   totalTurnAroundTime += turnAroundTime[index];
                   removeProcess(current.processID);
                   waitingTime[index] = -1;
               }
           }
           current = current.next;
           index = (index + 1) % totalProcesses;
       }

       System.out.println("Average Waiting Time: " + (double) totalWaitingTime / totalProcesses);
       System.out.println("Average Turnaround Time: " + (double) totalTurnAroundTime / totalProcesses);
   }

   public void displayProcesses() {
       if (head == null) return;
       Process current = head;
       do {
           System.out.println("Process ID: " + current.processID + ", Burst Time: " + current.burstTime + ", Priority: " + current.priority);
           current = current.next;
       } while (current != head);
   }

   public static void main(String[] args) {
       RoundRobin scheduler = new RoundRobin();
       Scanner scanner = new Scanner(System.in);

       while (true) {
           System.out.println("1. Add Process");
           System.out.println("2. Display Processes");
           System.out.println("3. Simulate Round Robin");
           System.out.println("4. Exit");
           int choice = scanner.nextInt();

           switch (choice) {
               case 1:
                   System.out.print("Enter Process ID: ");
                   int processID = scanner.nextInt();
                   System.out.print("Enter Burst Time: ");
                   int burstTime = scanner.nextInt();
                   System.out.print("Enter Priority: ");
                   int priority = scanner.nextInt();
                   scheduler.addProcess(processID, burstTime, priority);
                   break;
               case 2:
                   scheduler.displayProcesses();
                   break;
               case 3:
                   System.out.print("Enter Time Quantum: ");
                   int timeQuantum = scanner.nextInt();
                   scheduler.simulateRoundRobin(timeQuantum);
                   break;
               case 4:
                   scanner.close();
                   return;
           }
       }
   }
}




7. Singly Linked List: Social Media Friend Connections
Problem Statement: Create a system to manage social media friend connections using a singly linked list. Each node represents a user with User ID, Name, Age, and List of Friend IDs. Implement the following operations:
Add a friend connection between two users.
Remove a friend connection.
Find mutual friends between two users.
Display all friends of a specific user.
Search for a user by Name or User ID.
Count the number of friends for each user.
Hint:
Use a singly linked list where each node contains a list of friends (which can be another linked list or array of Friend IDs).
For mutual friends, traverse both lists and compare the Friend IDs.
The List of Friend IDs for each user can be implemented as a nested linked list or array.
array.
import java.util.ArrayList;
import java.util.List;

class User {
   int userId;
   String name;
   int age;
   List<Integer> friendIds;
   User next;

   User(int userId, String name, int age) {
       this.userId = userId;
       this.name = name;
       this.age = age;
       this.friendIds = new ArrayList<>();
       this.next = null;
   }
}

class SocialMedia {
   private User head;

   public void addUser(int userId, String name, int age) {
       User newUser = new User(userId, name, age);
       if (head == null) {
           head = newUser;
       } else {
           User temp = head;
           while (temp.next != null) {
               temp = temp.next;
           }
           temp.next = newUser;
       }
   }

   public void addFriendConnection(int userId1, int userId2) {
       User user1 = findUserById(userId1);
       User user2 = findUserById(userId2);
       if (user1 != null && user2 != null) {
           if (!user1.friendIds.contains(userId2)) user1.friendIds.add(userId2);
           if (!user2.friendIds.contains(userId1)) user2.friendIds.add(userId1);
       }
   }

   public void removeFriendConnection(int userId1, int userId2) {
       User user1 = findUserById(userId1);
       User user2 = findUserById(userId2);
       if (user1 != null && user2 != null) {
           user1.friendIds.remove(Integer.valueOf(userId2));
           user2.friendIds.remove(Integer.valueOf(userId1));
       }
   }

   public List<Integer> findMutualFriends(int userId1, int userId2) {
       User user1 = findUserById(userId1);
       User user2 = findUserById(userId2);
       List<Integer> mutualFriends = new ArrayList<>();
       if (user1 != null && user2 != null) {
           for (int friendId : user1.friendIds) {
               if (user2.friendIds.contains(friendId)) {
                   mutualFriends.add(friendId);
               }
           }
       }
       return mutualFriends;
   }

   public List<Integer> displayFriends(int userId) {
       User user = findUserById(userId);
       return user != null ? user.friendIds : new ArrayList<>();
   }

   public User searchUser(String name, int userId) {
       User temp = head;
       while (temp != null) {
           if (temp.name.equals(name) || temp.userId == userId) {
               return temp;
           }
           temp = temp.next;
       }
       return null;
   }

   public int countFriends(int userId) {
       User user = findUserById(userId);
       return user != null ? user.friendIds.size() : 0;
   }

   private User findUserById(int userId) {
       User temp = head;
       while (temp != null) {
           if (temp.userId == userId) {
               return temp;
           }
           temp = temp.next;
       }
       return null;
   }

   public static void main(String[] args) {
       SocialMedia sm = new SocialMedia();
       sm.addUser(1, "Ram", 25);
       sm.addUser(2, "Sham", 30);
       sm.addUser(3, "Chari", 20);

       sm.addFriendConnection(1, 2);
       sm.addFriendConnection(1, 3);

       System.out.println(sm.displayFriends(1));
       System.out.println(sm.findMutualFriends(1, 2));
       sm.removeFriendConnection(1, 2);
       System.out.println(sm.displayFriends(1));
       System.out.println(sm.countFriends(1));
       System.out.println(sm.searchUser("Chari", 0).name);
   }
}




8. Doubly Linked List: Undo/Redo Functionality for Text Editor
Problem Statement: Design an undo/redo functionality for a text editor using a doubly linked list. Each node represents a state of the text content (e.g., after typing a word or performing a command). Implement the following:
Add a new text state at the end of the list every time the user types or performs an action.
Implement the undo functionality (revert to the previous state).
Implement the redo functionality (revert back to the next state after undo).
Display the current state of the text.
Limit the undo/redo history to a fixed size (e.g., last 10 states).
Hint:
Use a doubly linked list where each node represents a state of the text.
The next pointer will represent the forward history (redo), and the prev pointer will represent the backward history (undo).
Keep track of the current state and adjust the next and prev pointers for undo/redo operations.
operations.
import java.util.LinkedList;

public class Undo {
   private static class Node {
       String text;
       Node prev, next;

       Node(String text) {
           this.text = text;
       }
   }

   private Node head, tail, current;
   private int size = 0;
   private final int maxSize = 10;

   public void addState(String text) {
       Node newNode = new Node(text);
       if (current != null) {
           current.next = null;
       }
       if (size == maxSize) {
           head = head.next;
           head.prev = null;
           size--;
       }
       if (tail == null) {
           head = tail = newNode;
       } else {
           tail.next = newNode;
           newNode.prev = tail;
           tail = newNode;
       }
       current = tail;
       size++;
   }

   public void undo() {
       if (current != null && current.prev != null) {
           current = current.prev;
       }
   }

   public void redo() {
       if (current != null && current.next != null) {
           current = current.next;
       }
   }

   public String getCurrentState() {
       return current != null ? current.text : "";
   }

   public static void main(String[] args) {
       Undo editor = new Undo();
       editor.addState("State1");
       editor.addState("State2");
       editor.addState("State3");
       System.out.println(editor.getCurrentState());
       editor.undo();
       System.out.println(editor.getCurrentState());
       editor.redo();
       System.out.println(editor.getCurrentState());
       editor.addState("State4");
       System.out.println(editor.getCurrentState());
       editor.undo();
       System.out.println(editor.getCurrentState());
   }
}



9. Circular Linked List: Online Ticket Reservation System
Problem Statement: Design an online ticket reservation system using a circular linked list, where each node represents a booked ticket. Each node will store the following information: Ticket ID, Customer Name, Movie Name, Seat Number, and Booking Time. Implement the following functionalities:
Add a new ticket reservation at the end of the circular list.
Remove a ticket by Ticket ID.
Display the current tickets in the list.
Search for a ticket by Customer Name or Movie Name.
Calculate the total number of booked tickets.

Hint:
Use a circular linked list to represent the ticket reservations, with the last node’s next pointer pointing to the first node.
When removing a ticket, update the circular pointers accordingly.
For displaying all tickets, traverse the list starting from the first node, looping back after reaching the last node.


import java.time.LocalDateTime;

class Ticket {
   int ticketId;
   String customerName;
   String movieName;
   String seatNumber;
   LocalDateTime bookingTime;
   Ticket next;

   public Ticket(int ticketId, String customerName, String movieName, String seatNumber, LocalDateTime bookingTime) {
       this.ticketId = ticketId;
       this.customerName = customerName;
       this.movieName = movieName;
       this.seatNumber = seatNumber;
       this.bookingTime = bookingTime;
       this.next = null;
   }
}

public class TicketReservationSystem {
   private Ticket head = null;

   public void addTicket(int ticketId, String customerName, String movieName, String seatNumber, LocalDateTime bookingTime) {
       Ticket newTicket = new Ticket(ticketId, customerName, movieName, seatNumber, bookingTime);
       if (head == null) {
           head = newTicket;
           head.next = head;
       } else {
           Ticket temp = head;
           while (temp.next != head) {
               temp = temp.next;
           }
           temp.next = newTicket;
           newTicket.next = head;
       }
   }

   public void removeTicket(int ticketId) {
       if (head == null) return;
       if (head.ticketId == ticketId && head.next == head) {
           head = null;
           return;
       }
       Ticket current = head, prev = null;
       do {
           if (current.ticketId == ticketId) {
               if (prev != null) {
                   prev.next = current.next;
               } else {
                   Ticket temp = head;
                   while (temp.next != head) {
                       temp = temp.next;
                   }
                   head = head.next;
                   temp.next = head;
               }
               return;
           }
           prev = current;
           current = current.next;
       } while (current != head);
   }

   public void displayTickets() {
       if (head == null) return;
       Ticket temp = head;
       do {
           System.out.println("Ticket ID: " + temp.ticketId + ", Customer Name: " + temp.customerName +
                   ", Movie Name: " + temp.movieName + ", Seat Number: " + temp.seatNumber +
                   ", Booking Time: " + temp.bookingTime);
           temp = temp.next;
       } while (temp != head);
   }

   public void searchTicket(String query) {
       if (head == null) return;
       Ticket temp = head;
       do {
           if (temp.customerName.equalsIgnoreCase(query) || temp.movieName.equalsIgnoreCase(query)) {
               System.out.println("Ticket ID: " + temp.ticketId + ", Customer Name: " + temp.customerName +
                       ", Movie Name: " + temp.movieName + ", Seat Number: " + temp.seatNumber +
                       ", Booking Time: " + temp.bookingTime);
           }
           temp = temp.next;
       } while (temp != head);
   }

   public int totalTickets() {
       if (head == null) return 0;
       int count = 0;
       Ticket temp = head;
       do {
           count++;
           temp = temp.next;
       } while (temp != head);
       return count;
   }

   public static void main(String[] args) {
       TicketReservationSystem system = new TicketReservationSystem();
       system.addTicket(1, "Alice", "Inception", "A1", LocalDateTime.now());
       system.addTicket(2, "Bob", "Interstellar", "B2", LocalDateTime.now());
       system.addTicket(3, "Charlie", "Dunkirk", "C3", LocalDateTime.now());

       system.displayTickets();
       System.out.println("Total Tickets: " + system.totalTickets());

       system.searchTicket("Alice");
       system.removeTicket(2);

       system.displayTickets();
       System.out.println("Total Tickets: " + system.totalTickets());
   }
}



